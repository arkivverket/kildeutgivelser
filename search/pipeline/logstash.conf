input {
    file
    {
        tags => "stattholder"
        path => [ "/var/data/xml/stattholder_xml/**/*.xml" ]
        start_position => "beginning"
        max_open_files => 9000
        codec => multiline
        {
            pattern => "</TEI>"
            negate => true
            what => "next"
            max_lines => 9000
            max_bytes => "20 MiB"
        }
    }
    jdbc {
        tags => "location"
        # Postgres jdbc connection string to our database, mydb
        jdbc_connection_string => "jdbc:postgresql://${POSTGRES_HOST}:${POSTGRES_PORT}/${POSTGRES_DB}"
        jdbc_user => "${POSTGRES_USER}"
        jdbc_password => "${POSTGRES_PASSWORD}"
        # The path to our downloaded jdbc driver
        jdbc_driver_library => "/app/drivers/postgresql-42.2.5.jar"
        # The name of the driver class for Postgresql
        jdbc_driver_class => "org.postgresql.Driver"
        # our query
        statement => 'SELECT loc.project_id, loc.date_created, loc.date_modified, loc.name, loc.country, loc.city, loc.latitude, loc.longitude, loc.region, loc.source,
                        ev_o.publication_id, ev_o.publication_version_id, ev_o.publication_manuscript_id, ev_o.publication_facsimile_id,
                        ev_o.publication_comment_id, ev_o.publication_facsimile_page, pub_c.id as "publication_collection_id"
                        FROM event ev
                        JOIN event_connection ev_c ON ev_c.event_id = ev.id
                        JOIN event_occurrence ev_o ON ev_o.event_id = ev.id
                        JOIN publication pub ON pub.id = ev_o.publication_id
                        JOIN publication_collection pub_c ON pub_c.id = pub.publication_collection_id
                        JOIN location loc ON ev_c.location_id = loc.id'
        schedule => "*/5 * * * *"
    }
    jdbc {
        tags => "subject"
        # Postgres jdbc connection string to our database, mydb
        jdbc_connection_string => "jdbc:postgresql://${POSTGRES_HOST}:${POSTGRES_PORT}/${POSTGRES_DB}"
        jdbc_user => "${POSTGRES_USER}"
        jdbc_password => "${POSTGRES_PASSWORD}"
        # The path to our downloaded jdbc driver
        jdbc_driver_library => "/app/drivers/postgresql-42.2.5.jar"
        # The name of the driver class for Postgresql
        jdbc_driver_class => "org.postgresql.Driver"
        # our query
        statement => 'SELECT sub.project_id, sub.date_created, sub.date_modified,
                        sub.first_name, sub.last_name, sub.type, sub.place_of_birth, sub.occupation, sub.preposition, sub.full_name,
                        sub.description, sub.legacy_id, sub.date_born, sub.date_deceased, sub.source,
                        ev_o.publication_id, ev_o.publication_version_id, ev_o.publication_manuscript_id, ev_o.publication_facsimile_id,
                        ev_o.publication_comment_id, ev_o.publication_facsimile_page, pub_c.id as "publication_collection_id"
                        FROM event ev
                        JOIN event_connection ev_c ON ev_c.event_id = ev.id
                        JOIN event_occurrence ev_o ON ev_o.event_id = ev.id
                        JOIN publication pub ON pub.id = ev_o.publication_id
                        JOIN publication_collection pub_c ON pub_c.id = pub.publication_collection_id
                        JOIN subject sub ON ev_c.subject_id = sub.id'
        schedule => "*/5 * * * *"
    }
    jdbc {
        tags => "tag"
        # Postgres jdbc connection string to our database, mydb
        jdbc_connection_string => "jdbc:postgresql://${POSTGRES_HOST}:${POSTGRES_PORT}/${POSTGRES_DB}"
        jdbc_user => "${POSTGRES_USER}"
        jdbc_password => "${POSTGRES_PASSWORD}"
        # The path to our downloaded jdbc driver
        jdbc_driver_library => "/app/drivers/postgresql-42.2.5.jar"
        # The name of the driver class for Postgresql
        jdbc_driver_class => "org.postgresql.Driver"
        # our query
        statement => 'SELECT tag.project_id, tag.date_created, tag.date_modified,
                        tag.name, tag.description, tag.legacy_id, tag.source,
                        ev_o.publication_id, ev_o.publication_version_id, ev_o.publication_manuscript_id, ev_o.publication_facsimile_id,
                        ev_o.publication_comment_id, ev_o.publication_facsimile_page, pub_c.id as "publication_collection_id"
                        FROM event ev
                        JOIN event_connection ev_c ON ev_c.event_id = ev.id
                        JOIN event_occurrence ev_o ON ev_o.event_id = ev.id
                        JOIN publication pub ON pub.id = ev_o.publication_id
                        JOIN publication_collection pub_c ON pub_c.id = pub.publication_collection_id
                        JOIN tag ON ev_c.tag_id = tag.id'
        schedule => "*/5 * * * *"
    }
}

filter
{
    if "stattholder" in [tags]{
        xml{
            source => "message"
            store_xml => false
            remove_namespaces => true
            xpath =>["string(//title)","HeadTitle"]
            xpath =>["string(//publisher)","publisher"]
            xpath =>["string(//origDate)","origDate"]
            xpath =>["string(//catRef/@target)","catRef"]
            xpath =>["string(//body/descendant::*)","textData"]
            xpath =>["//placeName/text()","placeName"]
            xpath =>["//persName/text()","persName"]
        }

        mutate {
            remove_field => [ "message" ]
        }

        mutate {
            add_field => {
                "TitleIndexed" => "%{HeadTitle}"
                "PublisherIndexed" =>"%{publisher}"
                "origDateIndexed" => "%{origDate}"
                "catRefIndexed" => "%{catRef}"
                "textDataIndexed" => "%{textData}"
                "placeNameIndexed" => "%{placeName}"
                "persNameIndexed" => "%{persName}"
            }
        }

        mutate{
            convert => {
                "TitleIndexed" => "string"
                "PublisherIndexed" => "string"
                "origDateIndexed" => "string"
                "catRefIndexed" => "string"
                "textDataIndexed" => "string"
            }
        }

        ##DATE CONVERT
        date {
            match => ["origDate","yyyy-mm-dd HH:mm:ss" ]
        }
    }
}

## Add your filters / logstash plugins configuration here
output {
    if "stattholder" in [tags]{
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "stattholder"
        }
    }
    if "location" in [tags]{
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "location"
            document_id => "%{occ_id}"
        }
    }
    if "subject" in [tags]{
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "subject"
            document_id => "%{occ_id}"
        }
    }
    if "tag" in [tags]{
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "tag"
            document_id => "%{occ_id}"
        }
    }
}
